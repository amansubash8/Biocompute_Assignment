BioCompute ML Assignment: 1D Signal ClassificationThis repository contains the code and analysis for the BioCompute Machine Learning Engineer assignment. The project's goal was to adapt the DeepSignal model for 1D nanopore signal classification and then implement an improved model architecture.Project Pipeline & RationaleData Exploration (1_Data_Exploration.ipynb): The real-world .pod5 dataset (control_rep2.pod5) was analyzed. It was determined that these files contain raw signal but lack the necessary methylation labels, which would require a complex bioinformatics pipeline (dorado, modkit) to generate.Dataset Creation: Per the assignment's "toy example" clause, a hybrid dataset was created. This dataset uses real biological noise from control_rep2.pod5 as a base and adds a synthetic, randomized spike to create a challenging, high-noise classification problem.Preprocessing: Two datasets were generated:_ultra (With Gaussian Smoothing): This is the final, recommended dataset. A Gaussian filter (sigma=0.8) is applied to smooth the high-frequency noise, improving the signal-to-noise ratio. This is generated by 2_Data_Preprocessing.ipynb._adv (Without Gaussian Smoothing): This is a secondary, more challenging dataset used for comparison. It is generated by 2_Data_Preprocessing_without_gaussian.ipynb.Modeling:Baseline (3_Model_Baseline.ipynb): An adaptation of the DeepSignal hybrid concept (parallel $\text{CNN} + \text{Bi-LSTM}$).Improved (4_Model_Improved.ipynb): A Deeper, Serial Hybrid ($\text{CNN} \to \text{CNN} \to \text{Bi-LSTM}$) with $\text{BatchNormalization}$ and $\text{Dropout}$ for improved feature extraction and stability.Evaluation (5_Evaluation_Report.ipynb): The models are compared on the test data, generating final $\text{AUC-ROC}$ curves, confusion matrices, and performance metric charts.Setup Instructions1. RequirementsPython (tested with 3.10.17+)control_rep2.pod5 file (available from the $\text{modbase-validation_2024.10}$ dataset)2. Environment SetupFrom your terminal, navigate to the project directory and run the following commands:Bash# 1. Create a virtual environment
python3 -m venv venv

# 2. Activate the environment
# On macOS/Linux:
source venv/bin/activate
# On Windows:
# .\venv\Scripts\activate

# 3. Install the required packages
pip install -r requirements.txt
(Note: A requirements.txt file should be created containing tensorflow, scipy, numpy, pandas, pod5, matplotlib, seaborn, and jupyter)Reproducing the Final Results (Recommended)These steps will reproduce the final, successful results (Accuracy $\approx 99\%$) using the smoothed _ultra dataset.Prerequisite: Ensure the control_rep2.pod5 file is in the root of the project directory.Generate the Smoothed Data:Run all cells in the 2_Data_Preprocessing.ipynb notebook. This will create the following files:X_train_ultra.npyy_train_ultra.npyX_test_ultra.npyy_test_ultra.npyTrain the Baseline Model:Run all cells in the 3_Model_Baseline.ipynb notebook. This will load the _ultra data, train the baseline model, and save the final model as baseline_model.keras.Train the Improved Model:Run all cells in the 4_Model_Improved.ipynb notebook. This will load the _ultra data, train the improved model for 50 epochs, and save the final model as improved_model_ultra.keras.Generate Final Report Figures:Run all cells in the 5_Evaluation_Report.ipynb notebook. This will load both saved models and the _ultra test data, generating the final comparison plots (ROC, confusion matrices, and bar chart) that match the results in the final report.(Optional) Reproducing the "Without Gaussian Smoothing" ResultsThese steps will reproduce the first experiment (Accuracy $\approx 73\%-89\%$) shown in Screenshot 2025-11-14 at 17.54.19.jpg.Generate the Noisy Data:Run all cells in 2_Data_Preprocessing_without_gaussian.ipynb. This will create the _adv files.Modify and Run Models:In 3_Model_Baseline.ipynb, 4_Model_Improved.ipynb, and 5_Evaluation_Report.ipynb, change the SAVE_PREFIX variable in the first cell from _ultra to _adv.Re-run all three notebooks (3, 4, and 5) in order. This will train the models on the noisier data and generate the comparison plots seen in the screenshot.
